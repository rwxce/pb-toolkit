import re
import sys
from pathlib import Path
from collections import defaultdict

# Root directory containing extracted SELECT files grouped by version.
SELECTS_DIR = Path(sys.argv[1])

# Root directory containing per-project metadata generated by extract_pbt_dependencies.py.
PROJECTS_DIR = Path(sys.argv[2])

# Regex to extract the originating PBL from SELECT files.
# Expected header format: "PBL: xxx.pbl"
PBL_RE = re.compile(r"(?i)^PBL:\s*([A-Za-z0-9_ .-]+\.pbl)")

# Regex to extract SELECT blocks from SQL text.
SELECT_RE = re.compile(r"(?is)\bselect\b[\s\S]+?(?=;|\Z)")


def parse_pbt_txt(path: Path) -> dict:
    """
    Parses a <project>.pbt.txt metadata file generated by extract_pbt_dependencies.py.

    Extracts:
      - Project name
      - PowerBuilder version
      - List of referenced PBLs (normalized, lowercase)

    Returns a dictionary:
      {
        "project": str | None,
        "version": str | None,
        "pbls": list[str]
      }
    """
    txt = path.read_text(encoding="utf-8", errors="ignore")

    project, version, pbls = None, None, []
    for line in txt.splitlines():
        line = line.strip()

        if line.startswith("Project:"):
            project = line.split(":", 1)[1].strip()

        elif line.startswith("Version:"):
            version = line.split(":", 1)[1].strip()

        elif line.startswith("- "):
            pbl = line[2:].strip()
            if pbl.endswith("(NOT FOUND)"):
                pbl = pbl.replace("(NOT FOUND)", "").strip()
            if pbl:
                pbls.append(pbl.lower())

    return {"project": project, "version": version, "pbls": pbls}


def extract_table_field_map(sql_text: str):
    """
    Extracts table → column mappings from SQL SELECT blocks.

    Processing steps:
      - Removes line comments.
      - Locates SELECT blocks.
      - Extracts selected fields and target table.
      - Normalizes column names.
      - Ignores '*' and unsupported expressions.

    Returns:
      dict[str, set[str]]  → { table_name : { column1, column2, ... } }
    """
    cleaned = re.sub(r"--.*", "", sql_text)
    blocks = SELECT_RE.findall(cleaned)

    result = defaultdict(set)

    for block in blocks:
        s = re.sub(r"\s+", " ", block.strip())

        # Extract SELECT fields
        m_fields = re.search(r"(?is)\bselect\b\s+(.*?)\s+\bfrom\b", s)
        if not m_fields:
            continue

        raw_fields = m_fields.group(1)
        raw_fields = re.sub(r"\binto\b.+", "", raw_fields, flags=re.I)
        raw_fields = re.sub(r"\bcount\s*\(.*?\)", "", raw_fields, flags=re.I)

        fields = [f.strip() for f in raw_fields.split(",") if f.strip()]

        # Extract table name
        m_table = re.search(r"(?is)\bfrom\b\s+([A-Za-z0-9_]+)", s)
        if not m_table:
            continue
        table = m_table.group(1).lower()

        for col in fields:
            col = re.sub(r"\(.*?\)", "", col)
            col = re.sub(r"\b(first|distinct)\b", "", col, flags=re.I)
            col = col.replace(":", "").strip()

            if not col or col == "*":
                continue

            if "." in col:
                col = col.split(".")[-1]

            result[table].add(col.lower())

    return result


def sanitize(name: str) -> str:
    """
    Produces a filesystem-safe identifier.
    Must match the normalization rules used by extract_pbt_dependencies.py.
    """
    name = re.sub(r'[<>:"/\\|?*]', '_', name)
    name = name.replace(" ", "_")
    name = re.sub(r'_+', '_', name)
    return name.strip("_")


def main():
    """
    Main execution workflow:

      - Iterates through all version folders in PROJECTS_DIR.
      - For each project:
          * Loads PBT metadata (project, version, PBL list).
          * Scans SELECT files for the same version.
          * Filters SELECTs belonging to PBLs used by the project.
          * Extracts table → column mappings.
          * Writes a summarized report per project.

    Output:
      A 'selects_summary.txt' file inside each project folder.
    """
    for version_dir in PROJECTS_DIR.iterdir():
        if not version_dir.is_dir():
            continue

        version = version_dir.name
        selects_version_dir = SELECTS_DIR / version

        if not selects_version_dir.exists():
            print(f"[WARN] No selects folder for version {version}")
            continue

        for pbt_dir in version_dir.iterdir():
            if not pbt_dir.is_dir():
                continue

            pbt_txt = next(pbt_dir.glob("*.pbt.txt"), None)
            if not pbt_txt:
                print(f"[WARN] No PBT TXT found in {pbt_dir}")
                continue

            meta = parse_pbt_txt(pbt_txt)
            pbls = set(meta["pbls"])

            full_map = defaultdict(set)

            # Process SELECT files per PBL
            for sel_file in selects_version_dir.rglob("*.txt"):
                raw = sel_file.read_text(encoding="utf-8", errors="ignore")
                lines = raw.splitlines()
                if not lines:
                    continue

                m = PBL_RE.match(lines[0])
                if not m:
                    continue

                sel_pbl = m.group(1).lower()

                # Filter SELECTs not belonging to this project
                if sel_pbl not in pbls:
                    continue

                table_map = extract_table_field_map(raw)
                for table, cols in table_map.items():
                    full_map[table].update(cols)

            out_file = pbt_dir / "selects_summary.txt"
            out_file.parent.mkdir(parents=True, exist_ok=True)

            with out_file.open("w", encoding="utf-8") as f:
                if not full_map:
                    f.write("-- No SELECTs detected --\n")
                else:
                    for table in sorted(full_map.keys()):
                        cols = ", ".join(sorted(full_map[table]))
                        f.write(f"{table}: {cols}\n")


if __name__ == "__main__":
    main()